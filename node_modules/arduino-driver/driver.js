const fs = require("fs");
const path = require("path");
const SerialPort = require("serialport");
const Delimiter = require('@serialport/parser-delimiter');
const deviceLayout = JSON.parse(fs.readFileSync(path.join(__dirname, "device.json"), "utf8"));
const sensorLayout = JSON.parse(fs.readFileSync(path.join(__dirname, "sensor.json"), "utf8"));
const models = JSON.parse(fs.readFileSync(path.join(__dirname, "models.json"), "utf8"));
deviceLayout.model.items = Object.keys(models);

module.exports = function(){
	let module = {};
	let devices = [];
	
	module.deviceLayout = deviceLayout;
	module.sensorLayout = sensorLayout;
	module.formattedName = "Arduino";
	module.sampleRate = 500;

	module.registerDevice = function(id, extraData){
		if(!id || !extraData || !extraData.hasOwnProperty("serialPort") || !extraData.hasOwnProperty("model") || devices[id] || !models[extraData.model]) return false;
		let device = {
			model: extraData.model,
			port: new SerialPort(extraData.serialPort.substring(0, extraData.serialPort.indexOf("(")), {baudRate: 9600}),
			sensors: [],
			cmdQueue: [],
			listeners: [],
			nextID: 0,
			serial: {
				owner: undefined,
				queue: [],
				updates: {}
			}
		};
		devices[id] = device;
		
		device.serial.parser = device.port.pipe(new Delimiter({ delimiter: 'E' }));
		device.serial.parser.on('data', (data) => {
			if(device.serial.owner === undefined)
				processQueue(device);
			else{
				device.serial.owner(data);
				device.serial.owner = undefined;
				processQueue(device);
			}
		});
		
		/*device.port.on("open", () => {
			setInterval(() => {
				// TODO: Get memory locs and save each to data
				let updates = {};
				for(const sensor of device.sensors) {
					if(sensor.sample === sensor.maxSamples) {
						updates[sensor.id] = data[index];
						sensor.sample = 0;
					}
				}
				for (const listener of device.listeners)
					listener(updates);
			}, 500);
		});*/
		
		return true;
	};
	
	module.registerSensor = function(deviceId, extraData, id){
		if(!deviceId || !extraData || !id || !devices[deviceId] || extraData.pin < 0) return false;
		let dev = devices[deviceId];
		if(extraData.pin > (extraData.pinType === "Digital" ? models[dev.model].maxDigital : models[dev.model].maxAnalog)) return false;
		let sensor = {pin: extraData.pin, id: id, isDigital: extraData.pinType === "Digital"};
		dev.sensors.push(sensor);
		return true;
	};
	
	module.unregisterSensor = function(device, id){
		if(!device || id === undefined || !devices[device]) return false;
		for(let i = 0; i < devices[device].sensors.length; i++){
			let sensor = devices[device].sensors[i];
			if(sensor.id === id){
				devices[device]._inputLocations.list = devices[device]._inputLocations.list.filter(pin => pin !== sensor.pin);
				devices[device]._inputLocations.changed = true;
				devices[device].sensors.splice(i, 1);
				return true;
			}
		}
		return false;
	};
	
	module.addListener = function(device, func){
		if(!devices[device]) return false;
		devices[device].listeners.push(func);
		return true;
	};

	module.refresh = function(){
		SerialPort.list().then(ports => {
			let pts = [];
			for(const port of Object.values(ports)) {
				if(port.vendorId === "2341"){
					let name = port.comName + " (";
					let found = false;
					for(const model of Object.keys(models)){
						if(Number.parseInt(port.productId) === Number.parseInt(models[model].modelId)){
							name += model;
							found = true;
							break;
						}
					}
					if(!found) name += "Unknown";
					pts.push(name + ")");
				}
			}
			if(pts.length > 0) deviceLayout.serialPort.items = pts;
		});
	};
	
	module.getSensorValue = function(deviceId, id){
		if(!deviceId || id === undefined || !devices[deviceId]) return undefined;
		let dev = devices[deviceId];
		for(const sensor of dev.sensors){
			if(sensor.id === id){
				return new Promise(resolve => {
					addCommand(dev,[getCharValue(sensor.isDigital ? 'R' : 'r'), Number.parseInt(sensor.pin), getCharValue('E')],(data) => {
						resolve(Number.parseInt(data));
					});
				});
			}
		}
		return undefined;
	};

	module.refresh();

	setInterval(() => {
		module.refresh();
	}, 5 * 1000);
	
	function addCommand(device, data, commandHandler){
		device.serial.queue.push({
			data: data,
			handler: commandHandler
		});
		if(device.serial.owner === undefined)
			processQueue(device);
	}
	
	function sendBytes(device, bytes){
		device.port.write(Buffer.from(bytes));
	}
	
	function processQueue(device){
		if(device.serial.queue.length > 0){
			let cmd = device.serial.queue.pop();
			device.serial.owner = cmd.handler;
			sendBytes(device, cmd.data);
			// TODO: Start timeout timer
		}
	}
	
	function getSensorValues(device){
		for(const sensor of device.sensors)
			sendBytes(device,[sensor.type === "Digital" ? 'R' : 'r', sensor.pin, 'E']);
	}
	
	function getCharValue(char){
		return char.charCodeAt(0);
	}
	
	return module;
};